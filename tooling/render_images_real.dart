// Render real SVGs for module image specs using external tools.
// Usage:
//   dart run tooling/render_images_real.dart [--module <id>] [--engine mermaid|pyplot|all]
//                                           [--size WxH] [--force] [--skip-unknown] [--quiet]
//
// Reads content/<module>/v1/spec.yml (as generated by gen_image_specs.dart) and renders
// images with engine == mermaid (via mmdc) or engine == pyplot (via python3 script).
// - mermaid: requires `mmdc` on PATH; runs: mmdc -i <src> -o <out> -b transparent
// - pyplot:  requires `python3` on PATH; runs: python3 <src> --out <out> --width <W> --height <H>
//
// ASCII-only. No new dependencies. Exit 0 if errors == 0, else 1.

import 'dart:io';

void main(List<String> args) async {
  String? onlyModule;
  var engineFilter = 'all'; // mermaid|pyplot|all
  var sizeW = 800;
  var sizeH = 400;
  var force = false;
  var skipUnknown = false;
  var quiet = false;

  for (var i = 0; i < args.length; i++) {
    final a = args[i];
    if (a == '--module' && i + 1 < args.length) {
      onlyModule = args[++i];
    } else if (a == '--engine' && i + 1 < args.length) {
      final v = args[++i].toLowerCase();
      if (v == 'mermaid' || v == 'pyplot' || v == 'all') engineFilter = v;
    } else if (a == '--size' && i + 1 < args.length) {
      final p = args[++i];
      final m = RegExp(r'^(\d+)x(\d+)$').firstMatch(p);
      if (m != null) {
        final w = int.tryParse(m.group(1)!);
        final h = int.tryParse(m.group(2)!);
        if (w != null && h != null && w > 0 && h > 0) {
          sizeW = w;
          sizeH = h;
        }
      }
    } else if (a == '--force') {
      force = true;
    } else if (a == '--skip-unknown') {
      skipUnknown = true;
    } else if (a == '--quiet') {
      quiet = true;
    }
  }

  final modules = _discoverModules(onlyModule);
  var rendered = 0;
  var skipped = 0;
  var errors = 0;
  var mermaidCount = 0;
  var pyplotCount = 0;

  // Tool availability cache
  bool? hasMmdc;
  bool? hasPy;

  for (final m in modules) {
    final v1 = Directory('content/$m/v1');
    final specFile = File('${v1.path}/spec.yml');
    if (!specFile.existsSync()) continue;

    _Spec spec;
    try {
      spec = _parseSpec(specFile.readAsLinesSync());
      if (spec.module.isEmpty) spec = spec.copyWith(module: m);
    } catch (e) {
      _perr(quiet, 'spec parse error in $m: $e');
      errors++;
      continue;
    }

    // Ensure images dir exists
    try {
      Directory('${v1.path}/images').createSync(recursive: true);
    } catch (e) {
      _perr(quiet, 'mkdir error for $m: $e');
      errors++;
      continue;
    }

    for (final img in spec.images) {
      final engine = (img.engine.isEmpty
          ? 'unknown'
          : img.engine.toLowerCase());
      if (engineFilter != 'all' && engine != engineFilter) {
        // Filtered out
        continue;
      }

      if (engine != 'mermaid' && engine != 'pyplot') {
        // Unknown engines are skipped by default; optionally acknowledge via flag.
        skipped++;
        continue;
      }

      final srcRel = img.src.trim();
      final outRel = (img.out.trim().isNotEmpty)
          ? img.out.trim()
          : 'images/${img.slug}.svg';
      if (srcRel.isEmpty) {
        _perr(quiet, '${spec.module}/${img.slug}: empty src');
        errors++;
        continue;
      }
      final srcPath = _joinPaths(v1.path, srcRel);
      final outPath = _joinPaths(v1.path, outRel);
      if (!File(srcPath).existsSync()) {
        _perr(quiet, '${spec.module}/${img.slug}: src not found: $srcRel');
        errors++;
        continue;
      }
      try {
        Directory(File(outPath).parent.path).createSync(recursive: true);
      } catch (e) {
        _perr(quiet, '${spec.module}/${img.slug}: mkdir failed: $e');
        errors++;
        continue;
      }

      final outFile = File(outPath);
      if (!force && outFile.existsSync()) {
        skipped++;
        continue;
      }

      if (engine == 'mermaid') {
        hasMmdc ??= await _toolOnPath('mmdc');
        if (hasMmdc != true) {
          _perr(quiet, 'mmdc not found on PATH');
          errors++;
          continue;
        }
        final code = await _run([
          'mmdc',
          '-i',
          srcPath,
          '-o',
          outPath,
          '-b',
          'transparent',
        ]);
        if (code != 0) {
          _perr(
            quiet,
            '${spec.module}/${img.slug}: mmdc failed with code $code',
          );
          errors++;
          continue;
        }
        rendered++;
        mermaidCount++;
      } else if (engine == 'pyplot') {
        hasPy ??= await _toolOnPath('python3');
        if (hasPy != true) {
          _perr(quiet, 'python3 not found on PATH');
          errors++;
          continue;
        }
        final code = await _run([
          'python3',
          srcPath,
          '--out',
          outPath,
          '--width',
          '$sizeW',
          '--height',
          '$sizeH',
        ]);
        if (code != 0) {
          _perr(
            quiet,
            '${spec.module}/${img.slug}: python3 script failed with code $code',
          );
          errors++;
          continue;
        }
        rendered++;
        pyplotCount++;
      }
    }
  }

  stdout.writeln(
    'RENDER-REAL rendered=$rendered skipped=$skipped errors=$errors engines=mermaid:$mermaidCount pyplot:$pyplotCount',
  );
  if (errors != 0) exitCode = 1;
}

void _perr(bool quiet, String msg) {
  if (!quiet) stderr.writeln(msg);
}

class _SpecImage {
  final String slug;
  final String caption;
  final String engine;
  final String src;
  final String out;
  final String status;
  _SpecImage({
    required this.slug,
    required this.caption,
    required this.engine,
    required this.src,
    required this.out,
    required this.status,
  });
}

class _Spec {
  final String module;
  final List<_SpecImage> images;
  _Spec({required this.module, required this.images});
  _Spec copyWith({String? module, List<_SpecImage>? images}) =>
      _Spec(module: module ?? this.module, images: images ?? this.images);
}

_Spec _parseSpec(List<String> lines) {
  var module = '';
  final images = <_SpecImage>[];
  var i = 0;
  while (i < lines.length) {
    final line = lines[i].trimRight();
    if (line.startsWith('module:')) {
      module = _stripQuotes(line.substring('module:'.length).trim());
      i++;
      continue;
    }
    if (line.trim() == 'images:') {
      i++;
      while (i < lines.length) {
        final l = lines[i];
        if (!l.startsWith('  - ')) break; // end of images block
        final slugLine = l.trimRight();
        final m = RegExp(r'^-\s+slug:\s*(.+)$').firstMatch(slugLine.trimLeft());
        if (m == null) throw 'invalid spec item header at line ${i + 1}';
        final slug = _stripQuotes(m.group(1)!.trim());
        var caption = '';
        var engine = 'unknown';
        var src = '';
        var out = 'images/$slug.svg';
        var status = 'todo';
        i++;
        while (i < lines.length) {
          final s = lines[i];
          if (s.startsWith('  - ')) break; // next item
          if (!s.startsWith('    ')) break; // end of this block
          final t = s.trim();
          final kv = t.split(':');
          if (kv.isEmpty) {
            i++;
            continue;
          }
          final key = kv.first.trim();
          final val = _stripQuotes(t.substring(key.length + 1).trim());
          switch (key) {
            case 'caption':
              caption = val;
              break;
            case 'engine':
              engine = val;
              break;
            case 'src':
              src = val;
              break;
            case 'out':
              if (val.isNotEmpty) out = val;
              break;
            case 'status':
              status = val;
              break;
            default:
              // ignore others
              break;
          }
          i++;
        }
        images.add(
          _SpecImage(
            slug: slug,
            caption: caption,
            engine: engine,
            src: src,
            out: out,
            status: status,
          ),
        );
      }
      continue;
    }
    i++;
  }
  return _Spec(module: module, images: images);
}

List<String> _discoverModules(String? only) {
  final root = Directory('content');
  if (!root.existsSync()) return <String>[];
  final out = <String>[];
  for (final e in root.listSync()) {
    if (e is! Directory) continue;
    final id = _basename(e.path);
    if (id.isEmpty || id.startsWith('_')) continue;
    if (only != null && id != only) continue;
    final v1 = Directory('${e.path}/v1');
    if (v1.existsSync()) out.add(id);
  }
  out.sort();
  return out;
}

String _basename(String path) {
  final norm = path.replaceAll('\\', '/');
  var s = norm;
  if (s.endsWith('/')) s = s.substring(0, s.length - 1);
  final idx = s.lastIndexOf('/');
  return idx == -1 ? s : s.substring(idx + 1);
}

String _stripQuotes(String s) {
  if (s.length >= 2 && s.startsWith('"') && s.endsWith('"')) {
    final inner = s.substring(1, s.length - 1);
    return inner.replaceAll('\\"', '"').replaceAll('\\n', '\n');
  }
  return s;
}

String _joinPaths(String a, String b) {
  final left = a.replaceAll('\\', '/');
  final right = b.replaceAll('\\', '/');
  if (left.endsWith('/')) return left + right;
  return left + '/' + right;
}

Future<bool> _toolOnPath(String cmd) async {
  // Try `which` (posix), then `where` (windows). Return true on success.
  try {
    final p = await Process.run('which', [cmd]);
    if ((p.exitCode == 0) && (p.stdout as String).toString().trim().isNotEmpty)
      return true;
  } catch (_) {}
  try {
    final p = await Process.run('where', [cmd]);
    if ((p.exitCode == 0) && (p.stdout as String).toString().trim().isNotEmpty)
      return true;
  } catch (_) {}
  return false;
}

Future<int> _run(List<String> cmd) async {
  try {
    final p = await Process.run(cmd.first, cmd.sublist(1));
    return p.exitCode;
  } catch (_) {
    return 1;
  }
}
