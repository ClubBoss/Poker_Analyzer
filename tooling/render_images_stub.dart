// Render placeholder SVGs for module image specs.
// Usage:
//   dart run tooling/render_images_stub.dart
//   dart run tooling/render_images_stub.dart --module <id>
//   dart run tooling/render_images_stub.dart --module <id> --force --size 800x400
//
// Reads content/<module>/v1/spec.yml (as generated by gen_image_specs.dart)
// and ensures each SVG at the declared `out` path exists by writing a
// deterministic placeholder. No external deps. ASCII-only.

import 'dart:io';

void main(List<String> args) {
  String? onlyModule;
  var force = false;
  var width = 800;
  var height = 400;

  // Flags: --module <id>, --force, --size WxH
  for (var i = 0; i < args.length; i++) {
    final a = args[i];
    if (a == '--module' && i + 1 < args.length) {
      onlyModule = args[++i];
    } else if (a == '--force') {
      force = true;
    } else if (a == '--size' && i + 1 < args.length) {
      final p = args[++i];
      final m = RegExp(r'^(\d+)x(\d+)$').firstMatch(p);
      if (m != null) {
        final w = int.tryParse(m.group(1)!);
        final h = int.tryParse(m.group(2)!);
        if (w != null && h != null && w > 0 && h > 0) {
          width = w;
          height = h;
        }
      }
    }
  }

  final modules = _discoverModules(onlyModule);
  var written = 0;
  var skipped = 0;
  final errors = 0;
  var ioError = false;

  for (final m in modules) {
    final v1 = Directory('content/$m/v1');
    final specFile = File('${v1.path}/spec.yml');
    if (!specFile.existsSync()) {
      // No spec -> nothing to render for this module
      continue;
    }
    _Spec spec;
    try {
      spec = _parseSpec(specFile.readAsLinesSync());
      if (spec.module.isEmpty) spec = spec.copyWith(module: m);
    } catch (e) {
      stderr.writeln('spec parse error in $m: $e');
      ioError = true;
      continue;
    }

    // Ensure images dir exists (use parent of each out path, but always create default images/ too)
    try {
      Directory('${v1.path}/images').createSync(recursive: true);
    } catch (e) {
      stderr.writeln('mkdir error for $m: $e');
      ioError = true;
      continue;
    }

    for (final img in spec.images) {
      final outRel = (img.out.isNotEmpty) ? img.out : 'images/${img.slug}.svg';
      final outPath = _joinPaths(v1.path, outRel);
      try {
        Directory(File(outPath).parent.path).createSync(recursive: true);
      } catch (e) {
        stderr.writeln('mkdir error for ${spec.module}/${img.slug}: $e');
        ioError = true;
        continue;
      }

      final f = File(outPath);
      if (!force && f.existsSync()) {
        skipped++;
        continue;
      }

      final svg = _placeholderSvg(
        width: width,
        height: height,
        title: img.slug,
        subtitle: img.caption,
        footer: '${spec.module}/${img.slug}',
      );

      try {
        f.writeAsStringSync(svg);
        written++;
      } catch (e) {
        stderr.writeln('write error for ${spec.module}/${img.slug}: $e');
        ioError = true;
      }
    }
  }

  stdout.writeln('written=$written, skipped=$skipped, errors=$errors');
  if (ioError) exitCode = 1;
}

class _SpecImage {
  final String slug;
  final String caption;
  final String out;
  _SpecImage({required this.slug, required this.caption, required this.out});
}

class _Spec {
  final String module;
  final List<_SpecImage> images;
  _Spec({required this.module, required this.images});
  _Spec copyWith({String? module, List<_SpecImage>? images}) =>
      _Spec(module: module ?? this.module, images: images ?? this.images);
}

_Spec _parseSpec(List<String> lines) {
  var module = '';
  final images = <_SpecImage>[];
  var i = 0;
  while (i < lines.length) {
    final line = lines[i].trimRight();
    if (line.startsWith('module:')) {
      module = _stripQuotes(line.substring('module:'.length).trim());
      i++;
      continue;
    }
    if (line.trim() == 'images:') {
      i++;
      while (i < lines.length) {
        final l = lines[i];
        if (!l.startsWith('  - ')) break; // end of images block
        final slugLine = l.trimRight();
        final m = RegExp(r'^-\s+slug:\s*(.+)$').firstMatch(slugLine.trimLeft());
        if (m == null) throw 'invalid spec item header at line ${i + 1}';
        final slug = _stripQuotes(m.group(1)!.trim());
        var caption = '';
        var out = 'images/$slug.svg';
        i++;
        while (i < lines.length) {
          final s = lines[i];
          if (s.startsWith('  - ')) break; // next item
          if (!s.startsWith('    ')) break; // end of this block
          final t = s.trim();
          final kv = t.split(':');
          if (kv.isEmpty) {
            i++;
            continue;
          }
          final key = kv.first.trim();
          final val = _stripQuotes(t.substring(key.length + 1).trim());
          switch (key) {
            case 'caption':
              caption = val;
              break;
            case 'out':
              if (val.isNotEmpty) out = val;
              break;
            default:
              // ignore others
              break;
          }
          i++;
        }
        images.add(_SpecImage(slug: slug, caption: caption, out: out));
      }
      continue;
    }
    i++;
  }
  return _Spec(module: module, images: images);
}

String _placeholderSvg({
  required int width,
  required int height,
  required String title,
  required String subtitle,
  required String footer,
}) {
  final w = width;
  final h = height;
  final t = _xmlEscape(title);
  final s = _xmlEscape(subtitle);
  final f = _xmlEscape(footer);
  return '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n'
      '<svg xmlns="http://www.w3.org/2000/svg" width="$w" height="$h" viewBox="0 0 $w $h">\n'
      '  <rect width="100%" height="100%" fill="#f8f9fa" stroke="#d0d0d0"/>\n'
      '  <text x="50%" y="45%" dominant-baseline="middle" text-anchor="middle" font-family="Arial, Helvetica, sans-serif" font-size="28" fill="#333">$t</text>\n'
      '  <text x="50%" y="60%" dominant-baseline="middle" text-anchor="middle" font-family="Arial, Helvetica, sans-serif" font-size="16" fill="#555">$s</text>\n'
      '  <text x="50%" y="90%" dominant-baseline="middle" text-anchor="middle" font-family="Arial, Helvetica, sans-serif" font-size="12" fill="#777">$f</text>\n'
      '</svg>\n';
}

String _stripQuotes(String s) {
  if (s.length >= 2 && s.startsWith('"') && s.endsWith('"')) {
    final inner = s.substring(1, s.length - 1);
    return inner.replaceAll('\\"', '"').replaceAll('\\n', '\n');
  }
  return s;
}

String _xmlEscape(String s) {
  var out = s;
  out = out.replaceAll('&', '&amp;');
  out = out.replaceAll('<', '&lt;');
  out = out.replaceAll('>', '&gt;');
  out = out.replaceAll('"', '&quot;');
  out = out.replaceAll("'", '&apos;');
  return out;
}

List<String> _discoverModules(String? only) {
  final root = Directory('content');
  if (!root.existsSync()) return <String>[];
  final out = <String>[];
  for (final e in root.listSync()) {
    if (e is! Directory) continue;
    final id = _basename(e.path);
    if (id.isEmpty || id.startsWith('_')) continue;
    if (only != null && id != only) continue;
    final v1 = Directory('${e.path}/v1');
    if (v1.existsSync()) out.add(id);
  }
  out.sort();
  return out;
}

String _basename(String path) {
  final norm = path.replaceAll('\\', '/');
  var s = norm;
  if (s.endsWith('/')) s = s.substring(0, s.length - 1);
  final idx = s.lastIndexOf('/');
  return idx == -1 ? s : s.substring(idx + 1);
}

String _joinPaths(String a, String b) {
  final left = a.replaceAll('\\', '/');
  final right = b.replaceAll('\\', '/');
  if (left.endsWith('/')) return left + right;
  return left + '/' + right;
}
