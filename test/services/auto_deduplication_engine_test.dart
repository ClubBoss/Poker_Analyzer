import 'package:test/test.dart';
import 'package:poker_analyzer/services/auto_deduplication_engine.dart';
import 'package:poker_analyzer/models/v2/training_pack_spot.dart';
import 'package:poker_analyzer/models/v2/hand_data.dart';
import 'package:poker_analyzer/models/v2/hero_position.dart';
import 'package:poker_analyzer/models/training_pack_model.dart';
import 'package:poker_analyzer/services/training_pack_library_service.dart';

void main() {
  test('deduplicates spots by fingerprint', () {
    final spot1 = TrainingPackSpot(
      id: 'a',
      hand: HandData(heroCards: 'Ah As', position: HeroPosition.sb),
      villainAction: 'fold',
    );
    final spot2 = TrainingPackSpot(
      id: 'b',
      hand: HandData(heroCards: 'As Ah', position: HeroPosition.sb),
      villainAction: 'fold',
    );
    final unique = TrainingPackSpot(
      id: 'c',
      hand: HandData(heroCards: 'Kd Kh', position: HeroPosition.bb),
      villainAction: 'call',
    );

    final engine = AutoDeduplicationEngine();
    final result = engine.deduplicateSpots([spot1, spot2, unique]);

    expect(result.length, 2);
    expect(result.where((s) => s.id == 'a').length, 1);
    expect(result.where((s) => s.id == 'b').isEmpty, isTrue);
    expect(result.where((s) => s.id == 'c').length, 1);
  });

  test('keeps highest weight when requested', () {
    final spot1 = TrainingPackSpot(
      id: 'a',
      hand: HandData(heroCards: 'Ah As', position: HeroPosition.sb),
      villainAction: 'fold',
      meta: {'weight': 1},
    );
    final spot2 = TrainingPackSpot(
      id: 'b',
      hand: HandData(heroCards: 'Ah As', position: HeroPosition.sb),
      villainAction: 'fold',
      meta: {'weight': 5},
    );

    final engine = AutoDeduplicationEngine();
    final result = engine.deduplicateSpots([
      spot1,
      spot2,
    ], keepHighestWeight: true);

    expect(result.length, 1);
    expect(result.first.id, 'b');
  });

  test('tracks number of skipped duplicates', () {
    final spot1 = TrainingPackSpot(
      id: 'a',
      hand: HandData(heroCards: 'Ah As', position: HeroPosition.sb),
      villainAction: 'fold',
    );
    final spot2 = TrainingPackSpot(
      id: 'b',
      hand: HandData(heroCards: 'As Ah', position: HeroPosition.sb),
      villainAction: 'fold',
    );

    final engine = AutoDeduplicationEngine();
    engine.deduplicateSpots([spot1, spot2]);

    expect(engine.skippedCount, 1);
  });

  test('run generates merge suggestions for similar packs', () async {
    final spot = TrainingPackSpot(
      id: 's1',
      hand: HandData(heroCards: 'Ah As', position: HeroPosition.sb),
      villainAction: 'fold',
    );
    final packA = TrainingPackModel(
      id: 'pA',
      title: 'A',
      spots: [spot],
      tags: ['tag1'],
    );
    final packB = TrainingPackModel(
      id: 'pB',
      title: 'B',
      spots: [spot, spot],
      tags: ['tag1'],
    );
    final packC = TrainingPackModel(
      id: 'pC',
      title: 'C',
      spots: [
        TrainingPackSpot(
          id: 's2',
          hand: HandData(heroCards: 'Kd Kc', position: HeroPosition.bb),
          villainAction: 'call',
        ),
      ],
      tags: ['tag2'],
    );

    final engine = AutoDeduplicationEngine(
      library: _MockLibrary([packA, packB, packC]),
    );
    final report = await engine.run(threshold: 0.8);

    expect(report.duplicates, hasLength(1));
    expect(report.mergeSuggestions.length, 1);
    final base = report.mergeSuggestions.keys.single;
    expect(base, 'pB');
    expect(report.mergeSuggestions[base], contains('pA'));
  });

  test('deduplicate removes autoGenerated pack when paired with manual', () {
    final spot = TrainingPackSpot(
      id: 's1',
      hand: HandData(heroCards: 'Ah As', position: HeroPosition.sb),
      villainAction: 'fold',
    );
    final manual = TrainingPackModel(
      id: 'manual',
      title: 'Manual',
      spots: [spot],
    );
    final auto = TrainingPackModel(
      id: 'auto',
      title: 'Auto',
      spots: [spot],
      tags: ['autoGenerated'],
      metadata: {'autoGenerated': true},
    );
    final engine = AutoDeduplicationEngine();
    final result = engine.deduplicate([manual, auto]);
    expect(result.map((p) => p.id), ['manual']);
  });

  test('deduplicate keeps oldest when both autoGenerated', () {
    final spot = TrainingPackSpot(
      id: 's1',
      hand: HandData(heroCards: 'Ah As', position: HeroPosition.sb),
      villainAction: 'fold',
    );
    final early = TrainingPackModel(
      id: 'early',
      title: 'Early',
      spots: [spot],
      tags: ['autoGenerated'],
      metadata: {'autoGenerated': true, 'createdAt': '2024-01-01T00:00:00Z'},
    );
    final late = TrainingPackModel(
      id: 'late',
      title: 'Late',
      spots: [spot],
      tags: ['autoGenerated'],
      metadata: {'autoGenerated': true, 'createdAt': '2024-01-02T00:00:00Z'},
    );
    final engine = AutoDeduplicationEngine();
    final result = engine.deduplicate([early, late]);
    expect(result.single.id, 'early');
  });
}

class _MockLibrary extends TrainingPackLibraryService {
  final List<TrainingPackModel> _packs;
  _MockLibrary(this._packs);

  @override
  Future<List<TrainingPackModel>> getAllPacks() async => _packs;
}
