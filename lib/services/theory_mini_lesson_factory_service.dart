import '../models/theory_mini_lesson_node.dart';
import '../models/theory_lesson_meta_data.dart';
import 'theory_lesson_meta_tag_extractor_service.dart';
import 'theory_mini_lesson_content_template_service.dart';

/// Builds [TheoryMiniLessonNode] instances from raw data and populates
/// autogenerated content when requested.
class TheoryMiniLessonFactoryService {
  final TheoryLessonMetaTagExtractorService _extractor;
  final TheoryMiniLessonContentTemplateService _templateService;

  const TheoryMiniLessonFactoryService({
    TheoryLessonMetaTagExtractorService? extractor,
    TheoryMiniLessonContentTemplateService? templateService,
  })  : _extractor = extractor ?? const TheoryLessonMetaTagExtractorService(),
        _templateService =
            templateService ?? const TheoryMiniLessonContentTemplateService();

  /// Creates a [TheoryMiniLessonNode] from [yaml]. When `autoContent` is true
  /// and `content` is empty, the node's `content` field will be populated using
  /// metadata extracted from tags and title.
  TheoryMiniLessonNode fromYaml(Map yaml) {
    final base = TheoryMiniLessonNode.fromYaml(yaml);
    final auto = yaml['autoContent'] as bool? ?? base.autoContent;
    if (!auto || base.content.isNotEmpty) return base;

    final meta = _extractor.extract(base);
    final keyTags = _buildKeyTags(base.tags, meta);

    var tempNode = TheoryMiniLessonNode(
      id: base.id,
      refId: base.refId,
      title: base.title,
      content: '',
      tags: keyTags,
      stage: base.stage,
      targetStreet: base.targetStreet ?? meta.street,
      nextIds: base.nextIds,
      linkedPackIds: base.linkedPackIds,
      recoveredFromMistake: base.recoveredFromMistake,
      autoContent: true,
    );

    tempNode = _templateService.withGeneratedContent(tempNode);
    final finalTags = {...base.tags, ...keyTags}.toList();

    return TheoryMiniLessonNode(
      id: tempNode.id,
      refId: tempNode.refId,
      title: tempNode.title,
      content: tempNode.content,
      tags: finalTags,
      stage: tempNode.stage,
      targetStreet: tempNode.targetStreet,
      nextIds: tempNode.nextIds,
      linkedPackIds: tempNode.linkedPackIds,
      recoveredFromMistake: tempNode.recoveredFromMistake,
      autoContent: true,
    );
  }

  List<String> _buildKeyTags(
    List<String> original,
    TheoryLessonMetaData meta,
  ) {
    final tags = <String>[];
    if (meta.position != null && meta.villainPosition != null) {
      tags.add('${meta.position} vs ${meta.villainPosition}');
    }
    final action = _extractAction(original);
    if (meta.street != null && action != null) {
      tags.add('${meta.street} $action');
    } else if (meta.street != null) {
      tags.add(meta.street!);
    }
    if (meta.boardTexture != null) {
      tags.add('${meta.boardTexture} Board');
    }
    return tags;
  }

  String? _extractAction(List<String> tags) {
    const actions = [
      'CBet',
      'Probe',
      'Check-Raise',
      '3-Bet',
      'Double Barrel',
      'Overbet',
      'Float',
      'Bet-3-Bet',
      'Donk Bet',
    ];
    for (final t in tags) {
      for (final a in actions) {
        if (t.toLowerCase().contains(a.toLowerCase())) return a;
      }
    }
    return null;
  }
}
