import 'dart:convert';

import 'package:shared_preferences/shared_preferences.dart';

import '../models/theory_goal.dart';
import 'mini_lesson_library_service.dart';
import 'theory_lesson_tag_clusterer.dart';
import 'theory_cluster_summary_service.dart';
import 'theory_goal_recommender.dart';
import 'tag_mastery_service.dart';
import 'session_log_service.dart';
import 'training_session_service.dart';
import '../utils/singleton_mixin.dart';

/// Singleton service that manages active theory goals generated by
/// [TheoryGoalRecommender].
class TheoryGoalEngine with SingletonMixin<TheoryGoalEngine> {
  final TheoryGoalRecommender recommender;
  final TheoryLessonTagClusterer clusterer;
  final TheoryClusterSummaryService summaryService;
  final MiniLessonLibraryService library;

  TheoryGoalEngine({
    TheoryGoalRecommender? recommender,
    TheoryLessonTagClusterer? clusterer,
    TheoryClusterSummaryService? summaryService,
    MiniLessonLibraryService? library,
  })  : recommender = recommender ??
            TheoryGoalRecommender(
              mastery: TagMasteryService(
                logs: SessionLogService(sessions: TrainingSessionService()),
              ),
            ),
        clusterer = clusterer ?? TheoryLessonTagClusterer(),
        summaryService = summaryService ?? TheoryClusterSummaryService(),
        library = library ?? MiniLessonLibraryService.instance;

  static TheoryGoalEngine get instance =>
      SingletonMixin.instance<TheoryGoalEngine>(() => TheoryGoalEngine());

  static const _prefsKey = 'theory_active_goals';
  static const _timeKey = 'theory_goals_updated';

  List<TheoryGoal> _activeGoals = [];
  DateTime _lastUpdated = DateTime.fromMillisecondsSinceEpoch(0);

  Future<void> _load() async {
    final prefs = await SharedPreferences.getInstance();
    final list = prefs.getStringList(_prefsKey);
    if (list != null) {
      try {
        _activeGoals = [
          for (final e in list)
            TheoryGoal.fromJson(jsonDecode(e) as Map<String, dynamic>),
        ];
      } catch (_) {
        _activeGoals = [];
      }
    }
    final tStr = prefs.getString(_timeKey);
    if (tStr != null) {
      _lastUpdated = DateTime.tryParse(tStr) ?? _lastUpdated;
    }
  }

  Future<void> _save() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setStringList(_prefsKey, [
      for (final g in _activeGoals) jsonEncode(g.toJson()),
    ]);
    await prefs.setString(_timeKey, _lastUpdated.toIso8601String());
  }

  /// Returns current theory goals, optionally refreshing if none are cached.
  Future<List<TheoryGoal>> getActiveGoals({bool autoRefresh = true}) async {
    if (_activeGoals.isEmpty) {
      await _load();
    }
    if (autoRefresh && _activeGoals.isEmpty) {
      await refreshGoals();
    }
    return List.unmodifiable(_activeGoals);
  }

  /// Generates and stores a new set of theory goals using [TheoryGoalRecommender].
  Future<void> refreshGoals() async {
    await library.loadAll();
    final clusters = await clusterer.clusterLessons();
    final summaries = summaryService.summarize(clusters);
    final lessons = {for (final l in library.all) l.id: l};
    final goals = await recommender.recommend(
      clusters: summaries,
      lessons: lessons,
    );
    final seen = <String>{};
    _activeGoals = [];
    for (final g in goals) {
      final key = g.tagOrCluster.trim().toLowerCase();
      if (seen.add(key)) _activeGoals.add(g);
    }
    _lastUpdated = DateTime.now();
    await _save();
  }

  /// Removes the goal for [tagOrCluster] if present.
  Future<void> markCompleted(String tagOrCluster) async {
    final key = tagOrCluster.trim().toLowerCase();
    _activeGoals.removeWhere((g) => g.tagOrCluster.trim().toLowerCase() == key);
    await _save();
  }

  /// Clears all stored theory goals.
  Future<void> clearAll() async {
    _activeGoals.clear();
    await _save();
  }
}
